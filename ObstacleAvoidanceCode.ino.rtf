{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww25400\viewh16000\viewkind0
\deftab720
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 \expnd0\expndtw0\kerning0
// ---------------------------------------------------------------------------
\f1\fs24 \

\f0\fs30 // This was our code for controlling obstacle avoidance of our quadcopter. We experimentally determined our proportional constants, and would like to include the PID library of Arduino in future experimentation.
\f1\fs24 \

\f0\fs30 // ---------------------------------------------------------------------------
\f1\fs24 \

\f0\fs30 #include <NewPing.h>
\f1\fs24 \

\f0\fs30 #include <Servo.h>
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 Servo Roll;
\f1\fs24 \

\f0\fs30 Servo Pitch;
\f1\fs24 \

\f0\fs30 Servo Throttle;
\f1\fs24 \

\f0\fs30 Servo Yaw;
\f1\fs24 \

\f0\fs30 Servo Aux;
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 #define SONAR_NUM \'a0\'a0\'a0\'a05 // Number of sensors.
\f1\fs24 \

\f0\fs30 #define MAX_DISTANCE 400 // Maximum distance (in cm) to ping.
\f1\fs24 \

\f0\fs30 #define PING_INTERVAL 33 // Milliseconds between sensor pings (29ms is about the min to avoid cross-sensor echo).
\f1\fs24 \

\f0\fs30 // #define TargetUnder 100 // Altitude to Maintain
\f1\fs24 \

\f0\fs30 #define TargetFront 45
\f1\fs24 \

\f0\fs30 #define TargetLeft 45
\f1\fs24 \

\f0\fs30 #define TargetRight 45
\f1\fs24 \

\f0\fs30 #define TargetBack 45
\f1\fs24 \

\f0\fs30 #define Kr 5
\f1\fs24 \

\f0\fs30 #define Kp 5
\f1\fs24 \

\f0\fs30 #define Kt 5
\f1\fs24 \

\f0\fs30 #define Ky 5
\f1\fs24 \

\f0\fs30 #define Ka 5
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\
\
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 unsigned long pingTimer[SONAR_NUM]; // Holds the times when the next ping should happen for each sensor.
\f1\fs24 \

\f0\fs30 unsigned int cm[SONAR_NUM];
\f1\fs24 \

\f0\fs30 int Rcontrol, Pcontrol, Tcontrol, Ycontrol, Acontrol, Rfreq = 1500, Pfreq = 1500, Tfreq = 1000, Yfreq = 1500, Afreq = 1000;
\f1\fs24 \

\f0\fs30 uint8_t currentSensor = 0; \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0// Keeps track of which sensor is active.
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 NewPing sonar[SONAR_NUM] = \{ \'a0\'a0\'a0\'a0// Sensor object array.
\f1\fs24 \

\f0\fs30  \'a0NewPing(12, 13, MAX_DISTANCE), // Each sensor's trigger pin, echo pin, and max distance to ping.
\f1\fs24 \

\f0\fs30  \'a0NewPing(10, 11, MAX_DISTANCE),
\f1\fs24 \

\f0\fs30  \'a0NewPing(8, 9, MAX_DISTANCE),
\f1\fs24 \

\f0\fs30  \'a0NewPing(10,11, MAX_DISTANCE)
\f1\fs24 \

\f0\fs30  \'a0NewPing(4, 5, MAX_DISTANCE)
\f1\fs24 \

\f0\fs30 \};
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 void setup() \{
\f1\fs24 \

\f0\fs30  \'a0Serial.begin(115200);
\f1\fs24 \

\f0\fs30  \'a0Roll.attach(A1);
\f1\fs24 \

\f0\fs30  \'a0Pitch.attach(A2);
\f1\fs24 \

\f0\fs30  \'a0Throttle.attach(A3);
\f1\fs24 \

\f0\fs30  \'a0Yaw.attach(A4);
\f1\fs24 \

\f0\fs30  \'a0Aux.attach(A5);
\f1\fs24 \

\f0\fs30  \'a0Throttle.writeMicroseconds(1000); // This sequence begins the arming procedure of the quad
\f1\fs24 \

\f0\fs30  \'a0Pitch.writeMicroseconds(1500);
\f1\fs24 \

\f0\fs30  \'a0Yaw.writeMicroseconds(1500);
\f1\fs24 \

\f0\fs30  \'a0Roll.writeMicroseconds(1500);
\f1\fs24 \

\f0\fs30  \'a0delay(5000);
\f1\fs24 \

\f0\fs30  \'a0Yaw.writeMicroseconds(2000);
\f1\fs24 \

\f0\fs30  \'a0delay(5500);
\f1\fs24 \

\f0\fs30  \'a0Yaw.writeMicroseconds(1500); // The quad should be armed and motors running here
\f1\fs24 \

\f0\fs30  \'a0Throttle.writeMicroseconds(1100); // This throttle command keeps quad from auto-shutting off
\f1\fs24 \

\f0\fs30  \'a0delay(3000);
\f1\fs24 \

\f0\fs30  \'a0pingTimer[0] = millis() + 75; \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0// First ping starts at 75ms, gives time for the Arduino to chill before starting.
\f1\fs24 \

\f0\fs30  \'a0for (uint8_t i = 1; i < SONAR_NUM; i++) // Set the starting time for each sensor.
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0pingTimer[i] = pingTimer[i - 1] + PING_INTERVAL;
\f1\fs24 \

\f0\fs30 \}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 void loop() \{
\f1\fs24 \

\f0\fs30  \'a0for (uint8_t i = 0; i < SONAR_NUM; i++) \{ // Loop through all the sensors.
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0if (millis() >= pingTimer[i]) \{ \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0// Is it this sensor's time to ping?
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\'a0\'a0pingTimer[i] += PING_INTERVAL * SONAR_NUM; \'a0// Set next time this sensor will be pinged.
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\'a0\'a0if (i == 0 && currentSensor == SONAR_NUM - 1) oneSensorCycle(); // Sensor ping cycle complete, do something with the results.
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\'a0\'a0sonar[currentSensor].timer_stop(); \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0// Make sure previous timer is canceled before starting a new ping (insurance).
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\'a0\'a0currentSensor = i; \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0// Sensor being accessed.
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\'a0\'a0cm[currentSensor] = 0; \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0// Make distance zero in case there's no ping echo for this sensor.
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\'a0\'a0sonar[currentSensor].ping_timer(echoCheck); // Do the ping (processing continues, interrupt will call echoCheck to look for echo).
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0\}
\f1\fs24 \

\f0\fs30  \'a0\}
\f1\fs24 \

\f0\fs30  \'a0// Other code that *DOESN'T* analyze ping results can go here.
\f1\fs24 \

\f0\fs30 \}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 void echoCheck() \{ // If ping received, set the sensor distance to array.
\f1\fs24 \

\f0\fs30  \'a0if (sonar[currentSensor].check_timer())
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0cm[currentSensor] = sonar[currentSensor].ping_result / US_ROUNDTRIP_CM;
\f1\fs24 \

\f0\fs30 \}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0 void oneSensorCycle() \{ // Sensor ping cycle complete, do something with the results.
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0  \'a0if (abs(cm[4] < TargetFront)) \{
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Rcontrol = 1500 + (TargetFront - cm[4]) * Kr;
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(Rcontrol);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(cm[4]);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Pitch.writeMicroseconds(Rcontrol);
\f1\fs24 \

\f0\fs30  \'a0\}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0  \'a0if (abs(cm[3] < TargetBack)) \{
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Rcontrol = 1500 - (TargetBack - cm[3]) * Kr;
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(Rcontrol);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(cm[3]);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Pitch.writeMicroseconds(Rcontrol);
\f1\fs24 \

\f0\fs30  \'a0\}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0  \'a0if (abs(cm[2] < TargetLeft)) \{
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Rcontrol = 1500 + (TargetLeft - cm[2]) * Kr;
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(Pcontrol);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(cm[2]);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Pitch.writeMicroseconds(Pcontrol);
\f1\fs24 \

\f0\fs30  \'a0\}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
\pard\pardeftab720\sl400\partightenfactor0

\f0\fs30 \cf0  \'a0if (abs(cm[1] < TargetRight)) \{
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Rcontrol = 1500 + (TargetRight - cm[1]) * Kr;
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(Pcontrol);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Serial.println(cm[1]);
\f1\fs24 \

\f0\fs30  \'a0\'a0\'a0Pitch.writeMicroseconds(Pcontrol);
\f1\fs24 \

\f0\fs30  \'a0\}
\f1\fs24 \

\f0\fs30 \}
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf0 \
}